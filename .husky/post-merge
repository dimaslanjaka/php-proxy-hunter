#!/bin/sh

# Determine the current script directory
SCRIPT_DIR=$(dirname "$(realpath "$0")")
USER="www-data"

# Detect if running on a VPS or desktop
IS_VPS=0
if [ -f /sys/class/dmi/id/product_name ]; then
  PRODUCT_NAME=$(cat /sys/class/dmi/id/product_name 2>/dev/null | tr '[:upper:]' '[:lower:]')
  if echo "$PRODUCT_NAME" | grep -qE "vps|virtual|kvm|qemu|xen|vmware|hyper-v|cloud"; then
    IS_VPS=1
  fi
fi

# Set CWD to the parent directory of this script directory
# Use realpath to resolve the parent; if that's not a git repo,
# fall back to using git's repository root detection.
CWD=$(realpath "$SCRIPT_DIR/.." 2>/dev/null || true)
if [ -z "$CWD" ] || ! git -C "$CWD" rev-parse --show-toplevel >/dev/null 2>&1; then
  CWD=$(git rev-parse --show-toplevel 2>/dev/null || true)
fi
if [ -z "$CWD" ]; then
  echo "Error: Unable to determine repository root"
  exit 1
fi

OS=$(uname -s)
# Apply crontab
if [ "$OS" = "Linux" ] && [ $IS_VPS -eq 1 ]; then
  sudo crontab -u "$USER" "$CWD/.crontab.txt"
fi

# Update submodules
if [ -f "$CWD/.gitmodules" ]; then
  echo "Updating submodules..."
  # Stash changes in each submodule before updating
  if [ -f "$CWD/.gitmodules" ]; then
    git submodule foreach --quiet '
      if [ -n "$(git status --porcelain)" ]; then
        echo "Stashing changes in submodule $name..."
        git stash push -u -m "pre-submodule-update"
      fi
    '
  fi

  # Update submodules
  git submodule update --init --recursive || {
    echo "Failed to update submodules"
    exit 1
  }

  # Pop stashed changes in each submodule after update
  if [ -f "$CWD/.gitmodules" ]; then
    git submodule foreach --quiet '
      if git stash list | grep -q "pre-submodule-update"; then
        echo "Restoring stashed changes in submodule $name..."
        git stash pop
      fi
    '
  fi
else
  echo "No submodules found, skipping update."
fi

# Run yarn
ViteLockFile="$CWD/tmp/locks/.dev-server-lock"
if command -v yarn >/dev/null 2>&1; then
  if [ $IS_VPS -eq 1 ]; then
    echo "Detected VPS environment. Installing production dependencies only."
    # Install production dependencies
    yarn workspaces focus --production || {
      echo "Yarn install failed."
    }
  else
    # Install all dependencies
    yarn install || {
      echo "Yarn install failed."
    }
    # Run the build script when the lock file is not present
    if [ ! -f "$ViteLockFile" ]; then
      node "$CWD/bin/build-project.mjs" || {
        echo "Build project failed."
      }
    fi
  fi
else
  echo "Error: Yarn is not installed. Skipping yarn operations."
fi

# Decide whether to run Composer: only when composer.json or any .php files changed
COMPOSER_LOCK="$CWD/composer.lock"
COMPOSER_PHAR="$CWD/bin/composer.phar"
COMPOSER_ARGS="--no-interaction"

if [ $IS_VPS -eq 1 ]; then
  # only install production dependencies on VPS
  echo "Detected VPS environment. Installing production dependencies only."
  COMPOSER_ARGS="--no-dev --no-interaction"
fi

# Determine previous ref to compare changes (prefer ORIG_HEAD, fallback to HEAD^)
PREV_REF=$(git -C "$CWD" rev-parse --verify ORIG_HEAD 2>/dev/null || git -C "$CWD" rev-parse --verify HEAD^ 2>/dev/null || true)
CUR_REF=$(git -C "$CWD" rev-parse --verify HEAD 2>/dev/null || true)
RUN_COMPOSER=0
if [ -n "$PREV_REF" ] && [ -n "$CUR_REF" ]; then
  CHANGED_FILES=$(git -C "$CWD" diff --name-only "$PREV_REF" "$CUR_REF")
  if echo "$CHANGED_FILES" | grep -qE '(^|/)composer\.json$|\.php$'; then
    RUN_COMPOSER=1
  fi
else
  # If we can't determine previous ref, be conservative and run composer if composer.json exists
  if [ -f "$CWD/composer.json" ]; then
    RUN_COMPOSER=1
  fi
fi

if [ "$RUN_COMPOSER" -eq 1 ]; then
  echo "Composer-relevant changes detected, running composer..."
  # Composer install/update (output redirected for debugging)
  if command -v php >/dev/null 2>&1; then
    # Check if the user exists
    if id -u "$USER" >/dev/null 2>&1; then
      # Run composer commands as the specified user
      if [ ! -f "$COMPOSER_LOCK" ]; then
        su -s /bin/sh -c "php $COMPOSER_PHAR install $COMPOSER_ARGS" "$USER"
      else
        su -s /bin/sh -c "php $COMPOSER_PHAR update $COMPOSER_ARGS" "$USER"
      fi
    else
      # Run composer as current user if target user does not exist
      if [ -f "$COMPOSER_LOCK" ]; then
        php $COMPOSER_PHAR update $COMPOSER_ARGS
      else
        php $COMPOSER_PHAR install $COMPOSER_ARGS
      fi
    fi
  else
    echo "Error: PHP is not installed. Skipping composer operations."
  fi
else
  echo "No composer.json or PHP file changes detected; skipping composer."
fi

# run commit history builder on non-VPS environments
if [ $IS_VPS -eq 0 ]; then
  node --no-warnings=ExperimentalWarning --loader ts-node/esm "$CWD/src/dev/git-history.builder.ts"
fi

# Fix permissions
OS=$(uname -s)
HOST=$(hostname)

# Check if running on Windows (Cygwin, MinGW, or MSYS)
if echo "$OS" | grep -q -E "CYGWIN|MINGW|MSYS"; then
  echo "No need change file permissions on windows"
# If running on Linux
elif [ "$OS" = "Linux" ]; then
  # Check if running under WSL/WSL2
  if grep -qiE 'microsoft|wsl' /proc/version 2>/dev/null; then
    echo "Skipping permission fix on WSL/WSL2"
  # Check if the hostname contains 'DESKTOP' (likely a Windows host)
  elif echo "$HOST" | grep -q 'DESKTOP'; then
    echo "Skipping permission fix on host: $HOST"
  else
    # If nginx is installed, proceed to fix permissions
    if command -v nginx >/dev/null 2>&1; then
      # Change directory to the Git root
      cd "$CWD" || exit
      # Run the permission fix script
      bash "$CWD/bin/fix-perm"
    fi
  fi
fi

# Auto generate hash and add .husky/hash.txt
if [ "$1" = "0" ]; then  # not a squash
  bash "$CWD/bin/cfh" || {
    echo "Failed to create file hashes"
    exit 1
  }
  git commit --amend --no-edit
fi
