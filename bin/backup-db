#!/bin/bash

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Project root (one level up from script dir)
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
# Use project-root locations for databases and backups
TMP_DB="$PROJECT_ROOT/tmp/database.sqlite"
SRC_DB="$PROJECT_ROOT/src/database.sqlite"
BACKUP_DIR="$PROJECT_ROOT/backups"

# Ensure system bin dirs are searched first so scripts find `sqlite3` and `mysqldump`
# when run from limited environments (cron, systemd). Project bins follow, then existing PATH.
export PATH="/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/bin:$PROJECT_ROOT/bin:$PROJECT_ROOT/node_modules/.bin:$PROJECT_ROOT/vendor/bin${PATH:+:$PATH}"

# Ensure backup directory creation
mkdir -p "$BACKUP_DIR"
chmod 700 "$BACKUP_DIR" 2>/dev/null || true

# Create .htaccess to protect backups directory
if [ ! -f "$BACKUP_DIR/.htaccess" ]; then
    mkdir -p "$BACKUP_DIR"
    {
        echo "Order Allow,Deny"
        echo "Deny from all"
    } > "$BACKUP_DIR/.htaccess"
fi

# Create index.html to prevent directory listing
if [ ! -f "$BACKUP_DIR/index.html" ]; then
    {
        echo "<!DOCTYPE html>"
        echo "<html><head><meta charset=\"UTF-8\"><title>403 Forbidden</title></head><body><h1>403 Forbidden</h1><p>Access to this directory is forbidden.</p></body></html>"
    } > "$BACKUP_DIR/index.html"
fi

# Load .env file (prefer project root `.env`, fallback to script dir)
if [ -f "$PROJECT_ROOT/.env" ]; then
    source "$PROJECT_ROOT/.env"
elif [ -f "$SCRIPT_DIR/.env" ]; then
    source "$SCRIPT_DIR/.env"
fi

# Create backup directory if it doesn't exist
mkdir -p "$BACKUP_DIR"

# Backup tmp database if it exists
if [ -f "$TMP_DB" ]; then
    if command -v sqlite3 >/dev/null 2>&1; then
        sqlite3 "$TMP_DB" .dump > "$BACKUP_DIR/python_database_backup_$(date +%Y-%m-%d).sql"
        echo "$TMP_DB -> $BACKUP_DIR/python_database_backup_$(date +%Y-%m-%d).sql"
    else
        echo "sqlite3 not installed; skipping backup of $TMP_DB"
    fi
fi

# Backup src database if it exists
if [ -f "$SRC_DB" ]; then
    if command -v sqlite3 >/dev/null 2>&1; then
        sqlite3 "$SRC_DB" .dump > "$BACKUP_DIR/php_database_backup_$(date +%Y-%m-%d).sql"
        echo "$SRC_DB -> $BACKUP_DIR/php_database_backup_$(date +%Y-%m-%d).sql"
    else
        echo "sqlite3 not installed; skipping backup of $SRC_DB"
    fi
fi

# Backup MySQL database
# Normalize and fallback env var names:
# - accept MYSQL_PASS -> MYSQL_PASSWORD
# - accept MYSQL_DBNAME -> MYSQL_DATABASE
# - accept production variants like MYSQL_USER_PRODUCTION when canonical vars are missing
if [ -z "$MYSQL_PASSWORD" ] && [ -n "$MYSQL_PASS" ]; then
    MYSQL_PASSWORD="$MYSQL_PASS"
fi
if [ -z "$MYSQL_DATABASE" ] && [ -n "$MYSQL_DBNAME" ]; then
    MYSQL_DATABASE="$MYSQL_DBNAME"
fi

# Fallback to production-specific variables if canonical ones are not set
if [ -z "$MYSQL_USER" ] && [ -n "$MYSQL_USER_PRODUCTION" ]; then
    MYSQL_USER="$MYSQL_USER_PRODUCTION"
fi
if [ -z "$MYSQL_PASSWORD" ] && [ -n "$MYSQL_PASS_PRODUCTION" ]; then
    MYSQL_PASSWORD="$MYSQL_PASS_PRODUCTION"
fi
if [ -z "$MYSQL_DATABASE" ] && [ -n "$MYSQL_DBNAME_PRODUCTION" ]; then
    MYSQL_DATABASE="$MYSQL_DBNAME_PRODUCTION"
fi
if [ -z "$MYSQL_HOST" ] && [ -n "$MYSQL_HOST_PRODUCTION" ]; then
    MYSQL_HOST="$MYSQL_HOST_PRODUCTION"
fi

if [ -n "$MYSQL_USER" ] && [ -n "$MYSQL_PASSWORD" ] && [ -n "$MYSQL_DATABASE" ]; then
    if ! command -v mysqldump >/dev/null 2>&1; then
        echo "mysqldump not installed; skipping MySQL backup"
    else
        mkdir -p "$BACKUP_DIR"
        BACKUP_FILE="$BACKUP_DIR/mysql-backup-$(date +%Y-%m-%d).sql"
        # Use a temporary defaults file to avoid passing the password on the command line
        CREDFILE=""
        if command -v mktemp >/dev/null 2>&1; then
            CREDFILE=$(mktemp)
        else
            CREDFILE="${BACKUP_DIR}/.mysql-cred-$$.cnf"
        fi
        if [ -n "$CREDFILE" ]; then
            chmod 600 "$CREDFILE" 2>/dev/null || true
            {
                echo "[client]"
                echo "user=${MYSQL_USER}"
                echo "password=${MYSQL_PASSWORD}"
                if [ -n "$MYSQL_HOST" ]; then
                    echo "host=${MYSQL_HOST}"
                fi
            } > "$CREDFILE"
            # ensure cleanup
            trap 'rm -f "${CREDFILE}"' EXIT
            # --defaults-extra-file must come first; wrap call to capture failures safely
            if mysqldump --defaults-extra-file="$CREDFILE" "$MYSQL_DATABASE" > "$BACKUP_FILE"; then
                echo "MySQL backup saved to $BACKUP_FILE"
            else
                status=$?
                echo "mysqldump failed with exit code $status"
            fi
            rm -f "$CREDFILE" || true
            trap - EXIT
        else
            # fallback: include host argument when provided; capture exit code safely
            if [ -n "$MYSQL_HOST" ]; then
                if mysqldump -h"$MYSQL_HOST" -u"$MYSQL_USER" -p"$MYSQL_PASSWORD" "$MYSQL_DATABASE" > "$BACKUP_FILE"; then
                    echo "MySQL backup saved to $BACKUP_FILE"
                else
                    status=$?
                    echo "mysqldump failed with exit code $status"
                fi
            else
                if mysqldump -u"$MYSQL_USER" -p"$MYSQL_PASSWORD" "$MYSQL_DATABASE" > "$BACKUP_FILE"; then
                    echo "MySQL backup saved to $BACKUP_FILE"
                else
                    status=$?
                    echo "mysqldump failed with exit code $status"
                fi
            fi
        fi
    fi
else
    echo "MySQL credentials not set in .env"
    echo "Required: one of MYSQL_USER or MYSQL_USER_PRODUCTION, and MYSQL_PASS/ MYSQL_PASS_PRODUCTION, and MYSQL_DBNAME or MYSQL_DBNAME_PRODUCTION (or set MYSQL_DATABASE)."
fi

