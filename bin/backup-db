#!/bin/bash

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Project root (one level up from script dir)
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
# Use project-root locations for databases and backups
TMP_DB="$PROJECT_ROOT/tmp/database.sqlite"
SRC_DB="$PROJECT_ROOT/src/database.sqlite"
BACKUP_DIR="$PROJECT_ROOT/backups"

# Ensure system bin dirs are searched first so scripts find `sqlite3` and `mysqldump`
# when run from limited environments (cron, systemd). Project bins follow, then existing PATH.
export PATH="/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/bin:$PROJECT_ROOT/bin:$PROJECT_ROOT/node_modules/.bin:$PROJECT_ROOT/vendor/bin${PATH:+:$PATH}"

PYTHON_CMD="$PROJECT_ROOT/bin/py"

# Ensure backup directory creation
mkdir -p "$BACKUP_DIR"
chmod 700 "$BACKUP_DIR" 2>/dev/null || true

# Create .htaccess to protect backups directory
if [ ! -f "$BACKUP_DIR/.htaccess" ]; then
    mkdir -p "$BACKUP_DIR"
    {
        echo "Order Allow,Deny"
        echo "Deny from all"
    } > "$BACKUP_DIR/.htaccess"
fi

# Create index.html to prevent directory listing
if [ ! -f "$BACKUP_DIR/index.html" ]; then
    {
        echo "<!DOCTYPE html>"
        echo "<html><head><meta charset=\"UTF-8\"><title>403 Forbidden</title></head><body><h1>403 Forbidden</h1><p>Access to this directory is forbidden.</p></body></html>"
    } > "$BACKUP_DIR/index.html"
fi

# Load .env file (prefer project root `.env`, fallback to script dir)
if [ -f "$PROJECT_ROOT/.env" ]; then
    source "$PROJECT_ROOT/.env"
elif [ -f "$SCRIPT_DIR/.env" ]; then
    source "$SCRIPT_DIR/.env"
fi

# Create backup directory if it doesn't exist
mkdir -p "$BACKUP_DIR"

# Backup tmp database if it exists
if [ -f "$TMP_DB" ]; then
    if command -v sqlite3 >/dev/null 2>&1; then
        sqlite3 "$TMP_DB" .dump > "$BACKUP_DIR/python_database_backup_$(date +%Y-%m-%d).sql"
        echo "$TMP_DB -> $BACKUP_DIR/python_database_backup_$(date +%Y-%m-%d).sql"
    else
        echo "sqlite3 not installed; skipping backup of $TMP_DB"
    fi
fi

# Backup src database if it exists
if [ -f "$SRC_DB" ]; then
    if command -v sqlite3 >/dev/null 2>&1; then
        sqlite3 "$SRC_DB" .dump > "$BACKUP_DIR/php_database_backup_$(date +%Y-%m-%d).sql"
        echo "$SRC_DB -> $BACKUP_DIR/php_database_backup_$(date +%Y-%m-%d).sql"
    else
        echo "sqlite3 not installed; skipping backup of $SRC_DB"
    fi
fi

# Backup MySQL database
# Normalize env var aliases and prefer production-specific variables when present
# - accept MYSQL_PASS -> MYSQL_PASSWORD
# - accept MYSQL_DBNAME -> MYSQL_DATABASE
# - prefer *_PRODUCTION values over canonical ones when available
# Map legacy aliases if canonical vars are absent (will be overridden by production vars if set)
if [ -z "$MYSQL_PASSWORD" ] && [ -n "$MYSQL_PASS" ]; then
    MYSQL_PASSWORD="$MYSQL_PASS"
fi
if [ -z "$MYSQL_DATABASE" ] && [ -n "$MYSQL_DBNAME" ]; then
    MYSQL_DATABASE="$MYSQL_DBNAME"
fi

# Prefer production-specific variables when provided. Only override canonical
# credentials when the production set includes at least user, password and host.
if [ -n "$MYSQL_USER_PRODUCTION" ] && [ -n "$MYSQL_PASS_PRODUCTION" ] && [ -n "$MYSQL_HOST_PRODUCTION" ]; then
    MYSQL_USER="$MYSQL_USER_PRODUCTION"
    MYSQL_PASSWORD="$MYSQL_PASS_PRODUCTION"
    MYSQL_HOST="$MYSQL_HOST_PRODUCTION"
    # Optionally override database name if provided in production vars
    if [ -n "$MYSQL_DBNAME_PRODUCTION" ]; then
        MYSQL_DATABASE="$MYSQL_DBNAME_PRODUCTION"
    fi
fi

if [ -n "$MYSQL_USER" ] && [ -n "$MYSQL_PASSWORD" ]; then
    if ! command -v mysqldump >/dev/null 2>&1; then
        echo "mysqldump not installed; skipping MySQL backup"
    else
        mkdir -p "$BACKUP_DIR"

        # Build list of databases to backup: include configured MYSQL_DATABASE plus extras
        DBS_TO_BACKUP=()
        if [ -n "$MYSQL_DATABASE" ]; then
            DBS_TO_BACKUP+=("$MYSQL_DATABASE")
        fi
        # Add the extra DBs requested by the user
        DBS_TO_BACKUP+=("myproject" "php_proxy_hunter_test")

        # Create a temporary credentials file to avoid exposing password on command line
        CREDFILE=""
        if command -v mktemp >/dev/null 2>&1; then
            CREDFILE=$(mktemp)
        else
            CREDFILE="${BACKUP_DIR}/.mysql-cred-$$.cnf"
        fi
        if [ -n "$CREDFILE" ]; then
            chmod 600 "$CREDFILE" 2>/dev/null || true
            {
                echo "[client]"
                echo "user=${MYSQL_USER}"
                echo "password=${MYSQL_PASSWORD}"
                if [ -n "$MYSQL_HOST" ]; then
                    echo "host=${MYSQL_HOST}"
                fi
            } > "$CREDFILE"
            trap 'rm -f "${CREDFILE}"' EXIT

            # Helper to check if a database exists
            db_exists() {
                local dbname="$1"
                if command -v mysql >/dev/null 2>&1; then
                    if mysql --defaults-extra-file="$CREDFILE" -N -s -e "SELECT SCHEMA_NAME FROM information_schema.SCHEMATA WHERE SCHEMA_NAME='${dbname}'" | grep -q "${dbname}"; then
                        return 0
                    else
                        return 1
                    fi
                else
                    # Fallback: attempt a harmless mysqldump header to test existence
                    if mysqldump --defaults-extra-file="$CREDFILE" --no-data --databases "${dbname}" >/dev/null 2>&1; then
                        return 0
                    else
                        return 1
                    fi
                fi
            }

            for DBNAME in "${DBS_TO_BACKUP[@]}"; do
                # skip empty names and duplicates
                if [ -z "$DBNAME" ]; then
                    continue
                fi
                if db_exists "$DBNAME"; then
                    BACKUP_FILE="$BACKUP_DIR/${DBNAME}-backup-$(date +%Y-%m-%d).sql"
                    echo "Backing up database '$DBNAME' to $BACKUP_FILE"
                    if mysqldump --defaults-extra-file="$CREDFILE" "$DBNAME" > "$BACKUP_FILE"; then
                        echo "MySQL backup saved to $BACKUP_FILE"
                    else
                        status=$?
                        echo "mysqldump for database '$DBNAME' failed with exit code $status"
                        rm -f "$BACKUP_FILE" >/dev/null 2>&1 || true
                    fi
                else
                    echo "Database '$DBNAME' does not exist or is not accessible; skipping."
                fi
            done

            rm -f "$CREDFILE" || true
            trap - EXIT
        else
            echo "Failed to create temporary credentials file; aborting MySQL backups"
        fi
    fi
else
    echo "MySQL credentials not set in .env"
    echo "Required: MYSQL_USER and MYSQL_PASSWORD (or production variants)."
fi

# Fix numpy installation to avoid issues during backup script execution
# "$PYTHON_CMD" -m pip uninstall -y numpy
# install build deps first (example for Debian/Ubuntu)
# apt update -y && apt install -y build-essential libatlas-base-dev gfortran
# "$PYTHON_CMD" -m pip install --no-binary :all: numpy===2.1.0
# "$PYTHON_CMD" -m pip install numpy===2.1.0 --force-reinstall

# "$PYTHON_CMD" -m pip install -r "$PROJECT_ROOT/requirements-minimal.txt"
"$PYTHON_CMD" -u "$PROJECT_ROOT/src/dev/backup-proxies.py"
